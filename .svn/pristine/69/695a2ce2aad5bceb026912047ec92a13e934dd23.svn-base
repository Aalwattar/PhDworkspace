/*****************************************************************************
* Filename:          /home/ahmed/works/PHD_RS/sched/PR_test/edk/drivers/math_v2_00_a/src/math.c
* Version:           2.00.a
* Description:       math Driver Source File
* Date:              Wed Jun 15 12:56:15 2011 (by Create and Import Peripheral Wizard)
*****************************************************************************/


/***************************** Include Files *******************************/

#include "headers.h"


struct ExecUnit MB1 = { .ID=1, .Busy=NO};

/* TODO Change to MATH_INTR_IPER_OFFSET to common constants */
/************************** Function Definitions ***************************/

/**
 *
 * Enable all possible interrupts from MATH device.
 *
 * @param   baseaddr_p is the base address of the MATH device.
 *
 * @return  None.
 *
 * @note    None.
 *
 */
void MATH_EnableInterrupt(void * baseaddr_p)
{
        Xuint32 baseaddr;
        baseaddr = (Xuint32) baseaddr_p;

        /*
         * Enable all interrupt source from user logic.
         */
        MATH_mWriteReg(baseaddr, MATH_INTR_IPIER_OFFSET, 0x00000001);

        /*
         * Enable all possible interrupt sources from device.
         */
        MATH_mWriteReg(baseaddr, MATH_INTR_DIER_OFFSET,
                       INTR_TERR_MASK
                       | INTR_DPTO_MASK
                       | INTR_IPIR_MASK
                      );

        /*
         * Set global interrupt enable.
         */
        MATH_mWriteReg(baseaddr, MATH_INTR_DGIER_OFFSET, INTR_GIE_MASK);
}




void MATH_DisableInterrupt(void * baseaddr_p)
{
        Xuint32 baseaddr;
        baseaddr = (Xuint32) baseaddr_p;

        /*
         * Enable all interrupt source from user logic.
         */
        MATH_mWriteReg(baseaddr, MATH_INTR_IPIER_OFFSET, 0x00000000);

        /*
         * Enable all possible interrupt sources from device.
         */
//  MATH_mWriteReg(baseaddr, MATH_INTR_DIER_OFFSET,
//    INTR_TERR_MASK
//    | INTR_DPTO_MASK
//    | INTR_IPIR_MASK
//    );

        /*
         * Set global interrupt enable.
         */
        MATH_mWriteReg(baseaddr, MATH_INTR_DGIER_OFFSET, 0x0);
}




/**
 *
 * Example interrupt controller handler for MATH device.
 * This is to show example of how to toggle write back ISR to clear interrupts.
 *
 * @param   baseaddr_p is the base address of the MATH device.
 *
 * @return  None.
 *
 * @note    None.
 *
 */

/* TODO check the peripheral interrupt status */

void MATH_Int_DefaultHandler(enum PRRID PRR_ID)
{
      //  Xuint32 IntrStatus;
      //  Xuint32 IpStatus;
        Xuint32 baseaddr=PRRs[PRR_ID].HW.BaseAddr;
        /*
         * Get status from Device Interrupt Status Register.
         */

      //  IntrStatus = MATH_mReadReg( baseaddr, MATH_INTR_DISR_OFFSET);

       // printf("Device Interrupt! PRR [%s] DISR value : 0x%08x \n\r", PRRs[PRR_ID].name,(unsigned int )IntrStatus);


        dfg1[PRRs[PRR_ID].DFGID].result =(int ) Xil_In32( baseaddr);
        dfg1[PRRs[PRR_ID].DFGID].Done =YES;
#if DEBUG_PRING
        printf("Device [%X] Result: %d\n\r ", baseaddr,dfg1[PRRs[PRR_ID].DFGID].result);
#endif

        /* TODO	 *  Enable the BUSY signal during configuration
         *  The PRR wont be accessible during that time
         */
        PRRs[PRR_ID].Busy=NO;
        State=TaskDone;
        GetElapsedTime(&dfg1[PRRs[PRR_ID].DFGID].Sim.ExecTV,&dfg1[PRRs[PRR_ID].DFGID].Sim.ExecTime);
        /*
         * Verify the source of the interrupt is the user logic and clear the interrupt
         * source by toggle write baca to the IP ISR register.
         */
        //if ((IntrStatus & INTR_IPIR_MASK) == INTR_IPIR_MASK) {
        //xil_printf("User logic interrupt! \n\r");
       // IpStatus = MATH_mReadReg( baseaddr, MATH_INTR_IPISR_OFFSET);
       // xil_printf("User logic interrupt! %x \n\r",IpStatus);
       // MATH_mWriteReg( baseaddr, MATH_INTR_IPISR_OFFSET, IpStatus);

//        }


}



void MATH0_Intr_Handler(void * ID )
{
//	Xuint32 baseaddr;
//	baseaddr = (Xuint32) baseaddr_p;
//	struct PRRIntData * PRR_Int_Data;
//			  PRR_Int_Data->Address =PRRs[Math0].HW.BaseAddr;
//			  PRR_Int_Data->ID = PRRs[Math0].ID;

        MATH_Int_DefaultHandler(Math0);
}

void MATH1_Intr_Handler(void* ID)
{

        MATH_Int_DefaultHandler(Math1);
}

void MATH2_Intr_Handler(void *ID)
{


        MATH_Int_DefaultHandler(Math2);
}

void MATH3_Intr_Handler(void*ID )
{

        MATH_Int_DefaultHandler(Math3);
}

void MATH4_Intr_Handler(void * ID)
{

        MATH_Int_DefaultHandler(Math4);
}
