/*
 * Copyright (c) 2009 Xilinx, Inc.  All rights reserved.
 *
 * Xilinx, Inc.
 * XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
 * COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
 * ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR
 * STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION
 * IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE
 * FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
 * XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
 * THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO
 * ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE
 * FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

/*
 * helloworld.c: simple test application
 */

#define PROCESSING 0
#define RECON		1
#include "headers.h"
#include "timer.h"
#include "queue.h"

static int SetupIntrSystem(XIntc *IntcInstancePtr, XMbox *MboxInstPtr,
                           u16 IntcDevId, u16 MboxIntrId);

#define MAX_QUEUE_TASKS 64
#define BUSY 1
#define QEmpty 3
#define ERROR 4
#define SUCCESS 0

static XMbox Mbox;
static XHwIcap HwIcap; /* The instance of the HWICAP device */
Queue ReadyQ;
Queue RecQ;
static u32 busyCounterSW=0;
static u32 busyCounterHW=0;
static u32 SW2HWMig=0;
static u32 HW2SWMig=0;

/*****************************************************************************
 * This Test if the node is ready by checking it's dependency .
 * If all the dependancy are are ready the it's ready .
 *
 * @param	u32 Node ID
 *
 * @return		True/False (Ready or not )
 *
 * @note		None.
 *
 ******************************************************************************/
int IsNodeReady(u32 id )
{
        if(dfg1[id].D.isAdd_op1 == NO && dfg1[id].D.isAdd_op2 ==NO) {
        //	 printf ("ID [%d]ready yes \r\n",id);
                return YES;
        }

        if (dfg1[id].D.isAdd_op1 == YES && dfg1[id].D.isAdd_op2 ==YES) {
       // 	printf ("ID [%d] is readysecond [%d] \r\n",id,dfg1[dfg1[id].D.op1].Done && dfg1[dfg1[id].D.op2].Done);
                return (dfg1[dfg1[id].D.op1].Done && dfg1[dfg1[id].D.op2].Done) ;
        }

        if (dfg1[id].D.isAdd_op1 ==YES) {

        //	printf ("ID [%d] is ready third[%d] \r\n",id,dfg1[dfg1[id].D.op1].Done);

                return dfg1[dfg1[id].D.op1].Done;

        }
     //   printf ("ID [%d] is ready final [%d] \r\n",id,dfg1[dfg1[id].D.op2].Done);
        return dfg1[dfg1[id].D.op2].Done;
}

int SchedSimple()
{
	 int i=0;


	do {

		if (IsNodeReady(i)== NO || dfg1[i].Q==YES  )
		{i++;
			continue;
		}

		switch (dfg1[i].mode) {

		case HybSW:
		case SWOnly:

			Enqueue(i,ReadyQ);
			dfg1[i].Q=YES;
			break;
		case HWOnly:
		case HybHW:

			Enqueue(i,ReadyQ);
			dfg1[i].Q=YES;
#if DEBUG_PRINT
			printf("Engueue %d \r\n",i);
#endif
			break;

		case CustomHW:
		case CustomHWnSW:
		default:
			print ("Unsupported mode check you DFG file .. Exiting\r\n");
			return XST_FAILURE;
		}
	i++;
	}while(i<=LAST_NODE);


 return XST_SUCCESS;
};


int ReusePRR(int module)
{
#if SIMPLE_SCHED_II_REUSE
	int i;
	for (i=0;i<AVAILABLE_PRR;i++)
	{
	if (PRRs[i].Current==module && PRRs[i].Busy==NO)
	{
#if DEBUG_PRINT
		printf("found module %d, reusing %d\r\n",module,i);
#endif
		return i;
	}
	}
#endif
	return -1;
}


int FindFreePRR()
{

	static int count=0;
	int i;
	//int j;
//	for (j=0;j<1;j++)
	//{
		for (i=count;i<AVAILABLE_PRR;i++)
		{
			if (PRRs[i].Busy== NO )
			{ count++;
#if DEBUG_PRINT
			printf("found free PRR %d\r\n",i);
#endif
			return i;
			}
		}
	if (count>AVAILABLE_PRR-1 )
	{
	//	print ("count is zero again \r\n");
		count=0;
	}
	//}
	//print("busy byssss \r\n");


	return -1;
}

int RunTask()
	{

	struct TimerValue tmpTV;
	int task;
	struct PRRMOD PRR_T;

#if SIMPLE_SCHED_SER
	static int i=0;
#endif
	int freePRR=5;

	u32 msgS[5] = { 1111, 2, 12, 10 ,20000000};
	msgS[0] = 1111;
	if (IsEmpty(ReadyQ))
		return QEmpty;
	task =Front(ReadyQ);


	PRR_T.Module= msgS[1] = dfg1[task].operation;

	msgS[2] = dfg1[task].D.isAdd_op1 ? dfg1[dfg1[task].D.op1].result
			: dfg1[task].D.op1;
	msgS[3] = dfg1[task].D.isAdd_op2 ? dfg1[dfg1[task].D.op2].result
			: dfg1[task].D.op2;
	msgS[4]=dfg1[task].Emu.HWdelay;


	switch (dfg1[task].mode) {

	case HybSW:

	case SWOnly:

		if (MB1.Busy== YES)
		{

#if SW_HW_MIG
			if(dfg1[task].mode==HybSW)
			{
			dfg1[task].mode=HybHW;
			SW2HWMig++;
#if DEBUG_PRINT
			printf("Task %d migrate from SW to Any\r\n",task);
#endif
			} else
			{
#endif
				busyCounterSW++;
				return BUSY;
		}

#if SW_HW_MIG
		}
#endif
		Dequeue(ReadyQ);
		dfg1[task].Sim.PRRUsed=100;
		MB1.Busy = YES;
		MB1.DFGID=task;
#if DEBUG_PRINT
		print("SW operation \r\n");
#endif

		/* TODO change to non blocking one */
		GetTime(&tmpTV);
		GetTime(&dfg1[task].Sim.ExecTV);
		msgS[4]=(u32) dfg1[task].Emu.SWdelay;
		XMbox_WriteBlocking(&Mbox, (u32*) (msgS), 20);
		GetElapsedTime(&tmpTV,&dfg1[task].Sim.ConfigTime);
#if DEBUG_PRINT
		printf(" op1 %ld  operation %ld op2 %ld \r\n", msgS[2],
				msgS[task], msgS[task]);
#endif
		//   i = dfg1[i].next;
		break;




	case HybHW:
	case HWOnly:

#if SIMPLE_SCHED_SER
		for (i=0 ; i<AVAILABLE_PRR ;i++)
		{
			if (PRRs[i].Busy== NO )
			{
				freePRR=i;
				break;
			}
		}
		if (freePRR>AVAILABLE_PRR-1)
		{
#if SW_HW_MIG
			if (MB1.Busy==NO && dfg1[task].mode==HybHW)
			{
				dfg1[task].mode=HybSW;
				HW2SWMig++;
#if DEBUG_PRINT
			printf("Task %d migrate from ANY to SW\r\n",task);
#endif

				return 0;
			}
			else
			{
#endif
			busyCounterHW++;
			return BUSY ;
#if SW_HW_MIG
			}
#endif
		}
#endif


#if SIMPLE_SCHED_II

		if ((freePRR=ReusePRR(PRR_T.Module )) <0)
		{
			if((freePRR=FindFreePRR())<0)
			{
#if SW_HW_MIG
				if (MB1.Busy==NO && dfg1[task].mode==HybHW)
				{
					dfg1[task].mode=HybSW;
					HW2SWMig++;
#if DEBUG_PRINT
			printf("Task %d migrate from HW to SW\r\n",task);
#endif
					return 0;
				}
				else
				{
#endif
					busyCounterHW++;
				return BUSY;
#if SW_HW_MIG
				}
#endif
				}
			Dequeue(ReadyQ);
			PRR_T.PRR_ID=freePRR;
			dfg1[task].Sim.PRRUsed=freePRR;
			dfg1[task].Sim.Reused=NO;




			GetTime(&tmpTV);
			Config(&PRR_T, &HwIcap);
			GetElapsedTime(&tmpTV,&dfg1[task].Sim.ConfigTime);
		} else

		{
			dfg1[task].Sim.PRRUsed=freePRR;
			dfg1[task].Sim.Reused=YES;
			Dequeue(ReadyQ);

		}

#endif



#if DEBUG_PRINT
		printf("Using PRR MATH%d \r\n",freePRR);
#endif
		PRR_T.PRR_ID=freePRR;

#if	SIMPLE_SCHED_SER

		Dequeue(ReadyQ);
		dfg1[task].Sim.PRRUsed=freePRR;
		dfg1[task].Sim.Reused=NO;
		GetTime(&tmpTV);
		Config(&PRR_T, &HwIcap,dfg1[task].Emu.HWdelay);
		GetElapsedTime(&tmpTV,&dfg1[task].Sim.ConfigTime);
#endif

		// print("HW accelerator \r\n");
		//   GetTime(&tmpTV);
		// XIntc_Stop(&IntcInst);

		// XIntc_Start(&IntcInst, XIN_REAL_MODE);
		// GetElapsedTime(&tmpTV,&simT[RECON][i]);

		PRRs[PRR_T.PRR_ID].DFGID=task;
		PRRs[PRR_T.PRR_ID].Busy= YES;
		GetTime(&dfg1[task].Sim.ExecTV);
		HWMath(msgS[2], msgS[3],PRR_T.PRR_ID);


		// i = dfg1[i].next;
		break;

	case CustomHW:
	case CustomHWnSW:
	default:
		print ("Unsupported mode check your DFG file .. Exiting\r\n");
		return XST_FAILURE;
	}
	return SUCCESS;
}

int main()
{



        //  Variables definition
        //static XHwIcap HwIcap; /* The instance of the HWICAP device */
       // XMbox Mbox;
        XMbox_Config *ConfigPtr;
        XUartLite UartLite;

        static XIntc IntcInst;
       // struct PRRMOD PRR_T;

       // u32 i = 0;
        int k ;
        //struct TimerValue tmpTV;
        struct TimerTime tmpT;
        struct TimerValue totalTV;
        /* FIXME fix this */
        struct TimerTime simT[2][6];
       // u32 msgS[4] = { 1111, 2, 12, 10 };

        int Status;
        XSysAce SysAce;
        XHwIcap_Config *ICAPConfigPtr;



        init_platform();
        XUartLite_Initialize(&UartLite, XPAR_UARTLITE_0_DEVICE_ID);








        Status = XSysAce_Initialize(&SysAce, XPAR_SYSACE_0_DEVICE_ID);
        if (Status != XST_SUCCESS) {
                print("Failed initializing SysACE \r\n");
                return XST_FAILURE;
        }


        ICAPConfigPtr = XHwIcap_LookupConfig(XPAR_XPS_HWICAP_0_DEVICE_ID);
        if (ICAPConfigPtr == NULL) {
                print("Failed configuring ICAP  \r\n");
                return XST_FAILURE;
        }

        Status = XHwIcap_CfgInitialize(&HwIcap, ICAPConfigPtr,
                                       ICAPConfigPtr->BaseAddress);
        if (Status != XST_SUCCESS) {

                print("Failed initializing ICAP \r\n");
                return XST_FAILURE;
        }
        print("HWICAP Initialized\r\n");

        //key = XUartLite_RecvByte(XPAR_UARTLITE_0_BASEADDR );


        ///////////PR END//////////////////////////////////////
        /*
         * TODO remove all init to a separate file
         * TODO Remove all print/printf commands or add #define debug preprocessor
         */
#if CONFIG_FROM_DDR
        Init_CF_Memory();
#endif

        print("Bitstreams moved to memroy ..\r\n");

        print("starting  server...... \n\r");
        if (mbox_init(&Mbox, ConfigPtr) != XST_SUCCESS) {
                print("Xbox initialization failure ... Exiting /r/n");
                return XST_FAILURE;
        }

        for (k=0 ; k<PRR_NUMBER; k++) {
                MATH_EnableInterrupt((void *) PRRs[k].HW.BaseAddr);
        }
        if (
                SetupIntrSystem(&IntcInst, &Mbox, INTC_DEVICE_ID, MBOX_INTR_ID)
                != XST_SUCCESS) {
                print("Interrupt initialization failure ... Exiting /r/n");
                return XST_FAILURE;
        }

        /*
         * Init Timers and enable the their corresponding interrupts
         */
        Status= InitTimer(&IntcInst);

        if (Status != XST_SUCCESS) {

                print("Timer INIT in main failed .. \r\n");
                return XST_FAILURE;

        }

        /*
         * Init QUEUES
         */

        ReadyQ=CreateQueue(MAX_QUEUE_TASKS);
        RecQ=CreateQueue(MAX_QUEUE_TASKS);
        Init_DFG();
        ResetTimer();
        TimerStart();
        TickTimerStart();
/* Reset Configuration Counter */
        ResetConfigCount();




        //	print("press any key to continue.... \r\n");
        //   inbyte();

        /* TODO change the ReadBlocking/Writeblocking function to  non blocking type */
     //   msgS[0] = 1111;
 //for (j=0 ;j<3; j++)

        GetTime(&totalTV);




do {
  switch(State)
  {
  case CfgDone:
	  RunTask();
	  State=TaskDone;
	  break;
  case TaskDone:
	  SchedSimple();
	  //SchedSimpleRc();
	  RunTask();
	  State=TaskDone;
	  break;
  case Start:
	  SchedSimple();
	 // SchedSimpleRc();
	  State=TaskDone;
	  break;
  case None:
   break;
  default :
	  print("ERROR: Unknown state ...\r\n");
	  break ;

  }


}while (dfg1[LAST_NODE].Done==NO );


        GetElapsedTime(&totalTV,&tmpT);

       print_DFG(simT );

        printf("Process complete in {%lu:%lu} Second \r\n",tmpT.Sec,tmpT.ThSec );
      printf ("Number of configuration= %lu SW Busy [%lu] HW Busy [%lu]\r\n",GetConfigCount(),busyCounterSW,busyCounterHW);
      printf("SW2HW MIG [%lu]  HW2SW Mig [%lu] \r\n",SW2HWMig,HW2SWMig);
        printf("Cleaning up ....\r\n\r\n\r\n");

        TimerStop();
        cleanup_platform();


        return 0;
}

///////////////////////////////////



/*****************************************************************************/
/** TODO move this function to a separate file
 *
 * This function setups the interrupt system such that interrupts can occur
 * for the Mailbox device. This function is application specific since the
 * actual system may or may not have an interrupt controller. The Mailbox
 * device could be directly connected to a processor without an Interrupt
 * controller.  The  user should modify this function to fit the application.
 *
 * @param	IntcInstancePtr is a pointer to the instance of the INTC
 *		component.
 * @param	MboxInstInstPtr is a pointer to the instance of the Mailbox.
 * @param	MboxIntrId is the interrupt Id and is typically
 *		XPAR_<INTC_instance>_<MBOX_instance>_IP2INTC_IRPT_INTR
 *		value from xparameters.h.
 *
 * @return	XST_SUCCESS if successful, otherwise XST_FAILURE.
 *
 * @note		None.
 *
 *****************************************************************************/
int SetupIntrSystem(XIntc *IntcInstancePtr, XMbox *MboxInstPtr,
                    u16 IntcDevId, u16 MboxIntrId)
{
        int Status;
        int i;
        //struct PRRIntData * PRR_Int_Data;

        /*
         * Initialize the interrupt controller driver so that it is ready to
         * use
         */
        Status = XIntc_Initialize(IntcInstancePtr, IntcDevId);
        if (Status != XST_SUCCESS) {
                return XST_FAILURE;
        }

        /*
         * Sets the Threshold
         */

        //		XMbox_SetSendThreshold(MboxInstPtr, MAILBOX_SIT);
        XMbox_SetReceiveThreshold(MboxInstPtr, MAILBOX_RIT);


        /*
         * Connect a device driver handler that will be called when an
         * interrupt for the device occurs, the device driver handler
         * performs the specific interrupt processing for the device
         */
        Status = XIntc_Connect(IntcInstancePtr, MboxIntrId,
                               (XInterruptHandler) MailboxIntrHandler, (void *) MboxInstPtr);
        if (Status != XST_SUCCESS) {
                return XST_FAILURE;
        }


        /* FIXME  lots of work in here */

        /*
         *	Connect the PRR regions interrupts to their corresponding ISR
         */
        if (XIntc_Connect(IntcInstancePtr, PRRs[Math0].HW.IntID,
                          (XInterruptHandler) MATH0_Intr_Handler,
                          (void*) Math0) != XST_SUCCESS) {
                print("Failed to register PRR MATH0  ISR exiting ..\r\n");
                return XST_FAILURE;
        }

        if (XIntc_Connect(IntcInstancePtr, PRRs[Math1].HW.IntID,
                          (XInterruptHandler) MATH1_Intr_Handler , (void*) Math1
                         ) != XST_SUCCESS) {
                print("Failed to register PRR MATH1  ISR exiting ..\r\n");
                return XST_FAILURE;
        }
        if (XIntc_Connect(IntcInstancePtr, PRRs[Math2].HW.IntID,
                          (XInterruptHandler) MATH2_Intr_Handler , (void*) Math2
                         ) != XST_SUCCESS) {
                print("Failed to register PRR MATH2  ISR exiting ..\r\n");
                return XST_FAILURE;
        }
        if (XIntc_Connect(IntcInstancePtr, PRRs[Math3].HW.IntID,
                          (XInterruptHandler) MATH3_Intr_Handler , (void*) Math3
                         ) != XST_SUCCESS) {
                print("Failed to register PRR MATH3  ISR exiting ..\r\n");
                return XST_FAILURE;
        }
        if (XIntc_Connect(IntcInstancePtr, PRRs[Math4].HW.IntID,
                          (XInterruptHandler) MATH4_Intr_Handler , (void*) Math4
                         ) != XST_SUCCESS) {
                print("Failed to register PRR MATH4  ISR exiting ..\r\n");
                return XST_FAILURE;
        }



        /*
         * The interrupt bits are not for FSL interface.
         */
        if (MboxInstPtr->Config.UseFSL == 0)
                XMbox_SetInterruptEnable(MboxInstPtr, XMB_IX_RTA); //XMB_IX_STA| XMB_IX_RTA | XMB_IX_ERR


        /*
         * Start the interrupt controller such that interrupts are enabled for
         * all devices that cause interrupts. Specify real mode so that
         * the Mbox can generate interrupts through
         * the interrupt controller
         */
        Status = XIntc_Start(IntcInstancePtr, XIN_REAL_MODE);
        if (Status != XST_SUCCESS) {
                return XST_FAILURE;
        }

        /*
         * Enable the interrupt for the Mbox
         */
        XIntc_Enable(IntcInstancePtr, MboxIntrId);

        for (i=0 ; i<PRR_NUMBER; i++) {
                XIntc_Enable(IntcInstancePtr, PRRs[i].HW.IntID);
        }




#ifndef TESTAPP_GEN
        Xil_ExceptionInit();

        Xil_ExceptionEnable();

        /*
         * Register the interrupt controller handler with the exception table.
         */
        Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                                     (Xil_ExceptionHandler) XIntc_InterruptHandler, IntcInstancePtr);
#endif /* TESTAPP_GEN */

        return XST_SUCCESS;
}



